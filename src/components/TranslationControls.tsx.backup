import React, { useState, useCallback } from 'react';
import { Play, Pause, Download, Settings } from 'lucide-react';
import { useSubtitle } from '@/contexts/SubtitleContext';
import { useTranslation } from '@/contexts/TranslationContext';
import { useTerms } from '@/contexts/TermsContext';
import { useHistory } from '@/contexts/HistoryContext';
import { TranslationHistoryEntry } from '@/types';
import { motion } from 'framer-motion';
import toast from 'react-hot-toast';
import localforage from 'localforage';

interface TranslationControlsProps {
  className?: string;
  onOpenSettings?: () => void;
}

export const TranslationControls: React.FC<TranslationControlsProps> = ({ 
  className,
  onOpenSettings 
}) => {
  const { 
    entries, 
    filename, 
    updateEntry, 
    exportSRT, 
    exportTXT, 
    exportBilingual,
    getTranslationProgress,
    getCurrentTaskId // è·å–å½“å‰ä»»åŠ¡ID
  } = useSubtitle();
  const {
    config,
    isTranslating,
    isPaused,
    progress,
    tokensUsed,
    isConfigured,
    abortController,
    translateBatch,
    updateProgress,
    toggleTranslation,
    startTranslation: initTranslation,
    stopTranslation,
    completeTranslation
  } = useTranslation();
  const { getRelevantTerms } = useTerms();
  const { addHistoryEntry } = useHistory(); // ä½¿ç”¨å†å²è®°å½•åŠŸèƒ½
  
  const [isExporting, setIsExporting] = useState(false);

  // ğŸ¯ æ‰¹æ¬¡çŠ¶æ€ç®¡ç†
  const initializeBatchStates = useCallback((batchSize: number) => {
    const totalBatches = Math.ceil(entries.length / batchSize);
    const batchStates = [];
    
    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      const startIdx = batchIndex * batchSize;
      const endIdx = Math.min(startIdx + batchSize, entries.length);
      const batchEntries = entries.slice(startIdx, endIdx);
      
      // æ£€æŸ¥æ‰¹æ¬¡æ˜¯å¦å·²å®Œæˆï¼ˆæ‰€æœ‰æ¡ç›®éƒ½æœ‰ç¿»è¯‘æ–‡æœ¬ï¼‰
      const isCompleted = batchEntries.every(entry => 
        entry.translatedText && entry.translatedText.trim() !== ''
      );
      
      batchStates.push({
        batchIndex,
        startIdx,
        endIdx,
        totalItems: batchEntries.length,
        status: isCompleted ? 'completed' : 'pending', // pending, processing, completed, failed
        entries: batchEntries
      });
    }
    
    return batchStates;
  }, [entries]);
  
  // ğŸ¯ æŒä¹…åŒ–æ‰¹æ¬¡çŠ¶æ€
  const saveBatchStates = useCallback(async (batchStates: any[]) => {
    try {
      const taskId = getCurrentTaskId();
      const batchStatesKey = `batch_states_${taskId}`;
      
      const batchData = {
        taskId,
        filename,
        totalBatches: batchStates.length,
        batchStates,
        lastUpdated: Date.now()
      };
      
      localStorage.setItem(batchStatesKey, JSON.stringify(batchData));
      console.log('æ‰¹æ¬¡çŠ¶æ€å·²ä¿å­˜:', batchData);
    } catch (error) {
      console.error('ä¿å­˜æ‰¹æ¬¡çŠ¶æ€å¤±è´¥:', error);
    }
  }, [getCurrentTaskId, filename]);
  
  // ğŸ¯ åŠ è½½æ‰¹æ¬¡çŠ¶æ€
  const loadBatchStates = useCallback(async (batchSize: number) => {
    try {
      const taskId = getCurrentTaskId();
      const batchStatesKey = `batch_states_${taskId}`;
      const savedData = localStorage.getItem(batchStatesKey);
      
      if (savedData) {
        const batchData = JSON.parse(savedData);
        console.log('åŠ è½½å·²ä¿å­˜çš„æ‰¹æ¬¡çŠ¶æ€:', batchData);
        return batchData.batchStates;
      }
    } catch (error) {
      console.error('åŠ è½½æ‰¹æ¬¡çŠ¶æ€å¤±è´¥:', error);
    }
    
    // å¦‚æœæ²¡æœ‰ä¿å­˜çš„çŠ¶æ€ï¼Œåˆå§‹åŒ–æ–°çš„çŠ¶æ€
    return initializeBatchStates(batchSize);
  }, [getCurrentTaskId, initializeBatchStates]);
  
  // ğŸ¯ æ›´æ–°æ‰¹æ¬¡çŠ¶æ€
  const updateBatchStatus = useCallback(async (batchIndex: number, status: string, batchStates: any[]) => {
    const updatedStates = [...batchStates];
    if (updatedStates[batchIndex]) {
      updatedStates[batchIndex].status = status;
      await saveBatchStates(updatedStates);
    }
    return updatedStates;
  }, [saveBatchStates]);

  const startTranslation = useCallback(async () => {
    if (!entries.length) {
      toast.error('è¯·å…ˆä¸Šä¼ SRTæ–‡ä»¶');
      return;
    }

    if (!isConfigured) {
      toast.error('è¯·å…ˆé…ç½®APIè®¾ç½®');
      onOpenSettings?.();
      return;
    }

    try {
      // åˆå§‹åŒ–ç¿»è¯‘çŠ¶æ€å¹¶è·å–AbortController
      const controller = await initTranslation();
      
      // è·å–å½“å‰ä»»åŠ¡ID
      const currentTaskId = getCurrentTaskId();
      
      // åˆå§‹åŒ–tokensç´¯è®¡å™¨ï¼Œä»å½“å‰å€¼å¼€å§‹
      let totalTokensUsed = tokensUsed;
      console.log('ç¿»è¯‘ä»»åŠ¡å·²å¯åŠ¨:', { taskId: currentTaskId, filename, entriesCount: entries.length, initialTokens: totalTokensUsed });

      const { batchSize, contextBefore, contextAfter, threadCount } = config;
      
      // ğŸ¯ åŠ è½½æˆ–åˆå§‹åŒ–æ‰¹æ¬¡çŠ¶æ€
      let batchStates = await loadBatchStates(batchSize);
      
      // ğŸ¯ æ›´å¯é çš„è¿›åº¦è·å–å‡½æ•°
      const getReliableProgress = async () => {
        let completedCount = 0;
        try {
          // ä» localStorage ä¸­è¯»å–æœ€æ–°çš„å­—å¹•æ•°æ®
          const currentTaskJson = localStorage.getItem('current_translation_task');
          if (currentTaskJson) {
            const currentTask = JSON.parse(currentTaskJson);
            if (currentTask.subtitle_entries) {
              completedCount = currentTask.subtitle_entries.filter(entry => 
                entry.translatedText && entry.translatedText.trim() !== ''
              ).length;
            }
          }
          
          // å¦‚æœ localStorage ä¸­æ²¡æœ‰æ•°æ®ï¼Œä½¿ç”¨ReactçŠ¶æ€
          if (completedCount === 0) {
            completedCount = entries.filter(entry => 
              entry.translatedText && entry.translatedText.trim() !== ''
            ).length;
          }
        } catch (error) {
          console.error('è¯»å–localStorageè¿›åº¦å¤±è´¥ï¼Œä½¿ç”¨ReactçŠ¶æ€:', error);
          completedCount = entries.filter(entry => 
            entry.translatedText && entry.translatedText.trim() !== ''
          ).length;
        }
        
        return {
          completed: completedCount,
          total: entries.length,
          percentage: Math.round((completedCount / entries.length) * 100)
        };
      };
      
      const actualProgress = await getReliableProgress();
      await updateProgress(actualProgress.completed, entries.length, 'direct', `å‡†å¤‡ç¿»è¯‘... (å·²å®Œæˆ: ${actualProgress.completed}/${entries.length})`, undefined, totalTokensUsed);

      // ğŸ¯ åŸºäºæ‰¹æ¬¡çŠ¶æ€çš„ç¿»è¯‘é€»è¾‘
      try {
        // è·å–æ‰€æœ‰æœªå®Œæˆçš„æ‰¹æ¬¡
        const pendingBatches = batchStates.filter(batch => batch.status === 'pending');
        
        if (pendingBatches.length === 0) {
          toast.success('æ‰€æœ‰æ‰¹æ¬¡éƒ½å·²å®Œæˆç¿»è¯‘ï¼');
          await completeTranslation(totalTokensUsed);
          return;
        }
        
        console.log(`å¼€å§‹æ‰¹æ¬¡çŠ¶æ€ç®¡ç†çš„ç¿»è¯‘: å¾…å¤„ç†æ‰¹æ¬¡ ${pendingBatches.length}, çº¿ç¨‹æ•° ${threadCount}`);
        
        // ä¸ºæœªå®Œæˆçš„æ‰¹æ¬¡å‡†å¤‡ç¿»è¯‘æ•°æ®
        const allBatches = [];
        for (const batchState of pendingBatches) {
          const { batchIndex, startIdx, endIdx } = batchState;
          const batchEntries = entries.slice(startIdx, endIdx);
          
          // è·³è¿‡å·²ç¿»è¯‘çš„æ¡ç›®
          const untranslatedEntries = batchEntries.filter(entry => 
            !entry.translatedText || !entry.translatedText.trim()
          );
          
          // å¦‚æœæ•´ä¸ªæ‰¹æ¬¡éƒ½å·²ç¿»è¯‘ï¼Œæ›´æ–°çŠ¶æ€å¹¶è·³è¿‡
          if (untranslatedEntries.length === 0) {
            console.log(`æ‰¹æ¬¡ ${batchIndex + 1} å·²å®Œæˆï¼Œæ›´æ–°çŠ¶æ€`);
            batchStates = await updateBatchStatus(batchIndex, 'completed', batchStates);
            continue;
          }
          
          // è·å–ä¸Šä¸‹æ–‡
          const contextBeforeTexts = entries
            .slice(Math.max(0, startIdx - contextBefore), startIdx)
            .map(e => e.text)
            .join('\n');
          
          const contextAfterTexts = entries
            .slice(endIdx, Math.min(entries.length, endIdx + contextAfter))
            .map(e => e.text)
            .join('\n');
          
          // è·å–ç›¸å…³æœ¯è¯­
          const batchText = untranslatedEntries.map(e => e.text).join(' ');
          const relevantTerms = getRelevantTerms(batchText);
          const termsText = relevantTerms
            .map(term => `${term.original} -> ${term.translation}`)
            .join('\n');

          const textsToTranslate = untranslatedEntries.map(e => e.text);
          
          allBatches.push({
            batchIndex,
            startIdx,
            endIdx,
            batchEntries,
            untranslatedEntries,
            textsToTranslate,
            contextBeforeTexts,
            contextAfterTexts,
            termsText
          });
        }
        
        console.log(`å®é™…éœ€è¦ç¿»è¯‘çš„æ‰¹æ¬¡: ${allBatches.length}`);
        
        // ğŸ¯ åŸºäºå®é™…çŠ¶æ€çš„è¿›åº¦æ›´æ–°
        const updateRealTimeProgress = async () => {
          let actualCompletedCount = 0;
          try {
            // ä» localStorage ä¸­è¯»å–æœ€æ–°çš„å­—å¹•æ•°æ®
            const currentTaskJson = localStorage.getItem('current_translation_task');
            if (currentTaskJson) {
              const currentTask = JSON.parse(currentTaskJson);
              if (currentTask.subtitle_entries) {
                actualCompletedCount = currentTask.subtitle_entries.filter(entry => 
                  entry.translatedText && entry.translatedText.trim() !== ''
                ).length;
              }
            }
            
            if (actualCompletedCount === 0) {
              await new Promise(resolve => setTimeout(resolve, 200));
              actualCompletedCount = entries.filter(entry => 
                entry.translatedText && entry.translatedText.trim() !== ''
              ).length;
            }
          } catch (error) {
            console.error('è¯»å–localStorageè¿›åº¦å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ:', error);
            await new Promise(resolve => setTimeout(resolve, 200));
            actualCompletedCount = entries.filter(entry => 
              entry.translatedText && entry.translatedText.trim() !== ''
            ).length;
          }
          
          const statusText = `ç¿»è¯‘ä¸­... (${actualCompletedCount}/${entries.length}) [${threadCount}çº¿ç¨‹] ${Math.round((actualCompletedCount / entries.length) * 100)}%`;
          
          await updateProgress(
            actualCompletedCount,
            entries.length,
            'direct',
            statusText,
            undefined,
            totalTokensUsed
          );
          
          console.log(`å®æ—¶è¿›åº¦æ›´æ–°: ${actualCompletedCount}/${entries.length} (${Math.round((actualCompletedCount / entries.length) * 100)}%)`);
        };
        
        // ğŸ¯ ç»Ÿä¸€æš‚åœé€»è¾‘ï¼šåŸºäºå®é™…çŠ¶æ€
        const performAtomicPause = async (reason: string) => {
          const actualProgress = await getReliableProgress();
          
          await updateProgress(
            actualProgress.completed,
            entries.length,
            'paused',
            `å·²æš‚åœ (è¿›åº¦: ${actualProgress.percentage}%) - ${reason}`,
            undefined, // ä¸å†ä½¿ç”¨æ‰¹æ¬¡ç´¢å¼•ï¼Œå› ä¸ºæˆ‘ä»¬ç°åœ¨æœ‰æ‰¹æ¬¡çŠ¶æ€
            totalTokensUsed
          );
          
          console.log(`æš‚åœçŠ¶æ€æ›´æ–° - çœŸå®å·²å®Œæˆ: ${actualProgress.completed}`);
          toast.success('ç¿»è¯‘å·²æš‚åœ');
        };
        
        // ğŸ¯ ç»ˆæ­¢æ‰€æœ‰æ­£åœ¨è¿›è¡Œçš„ç¿»è¯‘çº¿ç¨‹
        const abortAllBatches = () => {
          console.log('ç»ˆæ­¢æ‰€æœ‰æ­£åœ¨è¿›è¡Œçš„ç¿»è¯‘çº¿ç¨‹...');
          if (controller && !controller.signal.aborted) {
            controller.abort();
          }
        };
        

        // ğŸ¯ ä½¿ç”¨Promise.allè¿›è¡Œå¹¶å‘å¤„ç†ï¼ŒæŒ‰threadCountåˆ†ç»„
        for (let i = 0; i < allBatches.length; i += threadCount) {
          // æ£€æŸ¥æ˜¯å¦è¢«å–æ¶ˆ
          if (controller.signal.aborted) {
            await performAtomicPause('ç”¨æˆ·æ‰‹åŠ¨æš‚åœ');
            return;
          }
          
          // è·å–å½“å‰çº¿ç¨‹ç»„çš„æ‰¹æ¬¡
          const currentBatchGroup = allBatches.slice(i, i + threadCount);
          
          // æ ‡è®°å½“å‰æ‰¹æ¬¡ä¸ºâ€œå¤„ç†ä¸­â€
          for (const batch of currentBatchGroup) {
            batchStates = await updateBatchStatus(batch.batchIndex, 'processing', batchStates);
          }
          
          // å¹¶å‘å¤„ç†å½“å‰çº¿ç¨‹ç»„çš„æ‰¹æ¬¡
          const batchPromises = currentBatchGroup.map(async (batch) => {
            try {
              // ç¿»è¯‘å‰ï¼Œå†æ¬¡æ£€æŸ¥ä¸­æ­¢ä¿¡å·
              if (controller.signal.aborted) {
                console.log(`æ‰¹æ¬¡ ${batch.batchIndex + 1} åœ¨å¼€å§‹å‰è¢«ä¸­æ­¢`);
                await updateBatchStatus(batch.batchIndex, 'pending', batchStates);
                throw new Error('ç¿»è¯‘è¢«æš‚åœ');
              }
              
              // è®°å½•ç¿»è¯‘å‰çš„Tokenæ•°
              const beforeTokens = totalTokensUsed;
              
              // ä¼ å…¥AbortSignalè¿›è¡Œç¿»è¯‘
              const translationResult = await translateBatch(
                batch.textsToTranslate,
                controller.signal,
                batch.contextBeforeTexts,
                batch.contextAfterTexts,
                batch.termsText
              );
              
              // ğŸš€ åœ¨æ”¶åˆ°ç¿»è¯‘ç»“æœåç«‹å³ä¿å­˜ï¼Œç¡®ä¿ä¸ä¸¢å¤±æ•°æ®
              if (translationResult && translationResult.translations) {
                // æ›´æ–°æ¡ç›®
                translationResult.translations.forEach((translation: string, index: number) => {
                  if (batch.untranslatedEntries[index]) {
                    const entryIndex = entries.findIndex(e => e.id === batch.untranslatedEntries[index].id);
                    if (entryIndex !== -1 && translation && translation.trim()) {
                      updateEntry(entryIndex, translation.trim());
                    }
                  }
                });
                
                // ç­‰å¾…çŠ¶æ€åŒæ­¥
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // æ›´æ–°Tokenæ•°
                if (translationResult.tokensUsed) {
                  totalTokensUsed += translationResult.tokensUsed;
                }
                
                // æ›´æ–°è¿›åº¦
                await updateRealTimeProgress();
                
                // æ ‡è®°æ‰¹æ¬¡ä¸ºå·²å®Œæˆ
                batchStates = await updateBatchStatus(batch.batchIndex, 'completed', batchStates);
                
                console.log(`æ‰¹æ¬¡ ${batch.batchIndex + 1} ç¿»è¯‘å®Œæˆï¼ŒçŠ¶æ€å·²ä¿å­˜`);
                
                // åœ¨æ”¶åˆ°ç¿»è¯‘ç»“æœå¹¶ä¿å­˜åï¼Œå†æ£€æŸ¥ä¸­æ­¢ä¿¡å·
                if (controller.signal.aborted) {
                  console.log(`æ‰¹æ¬¡ ${batch.batchIndex + 1} ç¿»è¯‘å®Œæˆä½†æ”¶åˆ°å–æ¶ˆä¿¡å·ï¼Œç»“æœå·²ä¿å­˜`);
                  return { batchIndex: batch.batchIndex, success: true, completed: true };
                }
                
                return { batchIndex: batch.batchIndex, success: true };
              } else {
                throw new Error('ç¿»è¯‘ç»“æœä¸ºç©º');
              }
            } catch (error) {
              if (error.name === 'AbortError' || error.message?.includes('å–æ¶ˆ') || error.message?.includes('æš‚åœ')) {
                console.log(`æ‰¹æ¬¡ ${batch.batchIndex + 1} è¢«å–æ¶ˆ`);
                await updateBatchStatus(batch.batchIndex, 'pending', batchStates); // é‡ç½®ä¸ºå¾…å¤„ç†çŠ¶æ€
                return { batchIndex: batch.batchIndex, success: false, cancelled: true };
              } else {
                console.error(`æ‰¹æ¬¡ ${batch.batchIndex + 1} ç¿»è¯‘å¤±è´¥:`, error);
                await updateBatchStatus(batch.batchIndex, 'failed', batchStates);
                toast.error(`æ‰¹æ¬¡ ${batch.batchIndex + 1} ç¿»è¯‘å¤±è´¥: ${error}`);
                return { batchIndex: batch.batchIndex, success: false, error };
              }
            }
          });
          
          // ç­‰å¾…å½“å‰çº¿ç¨‹ç»„å®Œæˆ
          const results = await Promise.all(batchPromises);
          
          // æ£€æŸ¥ç»“æœ
          const successfulBatches = results.filter(r => r.success);
          const failedBatches = results.filter(r => !r.success && !r.cancelled);
          const cancelledBatches = results.filter(r => r.cancelled);
          
          console.log(`çº¿ç¨‹ç»„å®Œæˆ: æˆåŠŸ ${successfulBatches.length}, å¤±è´¥ ${failedBatches.length}, å–æ¶ˆ ${cancelledBatches.length}`);
          
          // å¦‚æœæœ‰å¤±è´¥çš„æ‰¹æ¬¡ï¼Œæ˜¾ç¤ºè­¦å‘Šä½†ç»§ç»­
          if (failedBatches.length > 0) {
            toast(`${failedBatches.length} ä¸ªæ‰¹æ¬¡ç¿»è¯‘å¤±è´¥ï¼Œå°†åœ¨ä¸‹æ¬¡ç»§ç»­æ—¶é‡è¯•`, { 
              icon: 'âš ï¸' 
            });
          }
          
          // å¦‚æœæœ‰å–æ¶ˆçš„æ‰¹æ¬¡ï¼Œè¯´æ˜ç”¨æˆ·æ‰‹åŠ¨æš‚åœäº†
          if (cancelledBatches.length > 0) {
            await performAtomicPause('ç¿»è¯‘è¿‡ç¨‹ä¸­æš‚åœï¼Œéƒ¨åˆ†ç»“æœå·²ä¿å­˜');
            return;
          }
          
          // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æ‰¹æ¬¡éƒ½å·²å®Œæˆ
          const remainingPendingBatches = batchStates.filter(b => b.status === 'pending' || b.status === 'failed');
          if (remainingPendingBatches.length === 0) {
            console.log('æ‰€æœ‰æ‰¹æ¬¡å·²å®Œæˆï¼');
            break;
          }
        }åœ¨updateRealTimeProgressä¸­æ›´æ–°äº†è¿›åº¦
          } catch (error) {
            // å¦‚æœæ˜¯å–æ¶ˆé”™è¯¯ï¼Œå¤„ç†æš‚åœé€»è¾‘
            if (error.name === 'AbortError' || error.message?.includes('å–æ¶ˆ')) {
              // ğŸš« ä¿®å¤ï¼šä½¿ç”¨åŸå­åŒ–æš‚åœæ›´æ–°ï¼Œé¿å…çŠ¶æ€ä¸ä¸€è‡´
              await performAtomicPause('ç¿»è¯‘è¿‡ç¨‹ä¸­æš‚åœ');
              return;
            }
            
            // å…¶ä»–é”™è¯¯ç»§ç»­å¤„ç†ä¸‹ä¸€ç»„
            console.error('çº¿ç¨‹ç»„å¤„ç†å¤±è´¥:', error);
          }
        }

        // æ­£å¸¸å®Œæˆ - ä½¿ç”¨å®é™…çŠ¶æ€ç¡®ä¿å‡†ç¡®æ€§
        const finalProgress = await getReliableProgress();
        await updateProgress(finalProgress.completed, entries.length, 'completed', 'ç¿»è¯‘å®Œæˆ', undefined, totalTokensUsed);
        
        // ä½¿ç”¨æ–°çš„completeTranslationå‡½æ•°ä¿æŒcompletedçŠ¶æ€
        await completeTranslation(totalTokensUsed);
        
        // ä¿å­˜å†å²è®°å½•ï¼ˆæ­¤æ—¶çŠ¶æ€æ˜¯'completed'ï¼ŒTokenæ•°æ®å®Œæ•´ï¼‰
        try {
          // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œç¡®ä¿ completeTranslation å·²å®Œæˆ
          await new Promise(resolve => setTimeout(resolve, 100));
          
          // è·å–å½“å‰ä»»åŠ¡çš„å®Œæ•´æ•°æ®
          const currentTaskData = await localforage.getItem('current_translation_task') as any;
          
          if (currentTaskData) {
            // ç¡®ä¿æ•°æ®å®Œæ•´æ€§
            const finalTokenCount = totalTokensUsed;
            currentTaskData.translation_progress.tokens = finalTokenCount;
            currentTaskData.translation_progress.status = 'completed';
            
            await addHistoryEntry({
              taskId: currentTaskId,
              filename: filename,
              completedCount: entries.length,
              totalTokens: finalTokenCount,
              current_translation_task: currentTaskData
            });
            
            console.log('å†å²è®°å½•å·²ä¿å­˜ - æœ€ç»ˆtokens:', finalTokenCount, 'çŠ¶æ€:', currentTaskData.translation_progress.status);
          } else {
            // å¤‡ç”¨æ–¹æ¡ˆï¼šæ„é€ å®Œæ•´çš„ä»»åŠ¡æ•°æ®
            await addHistoryEntry({
              taskId: currentTaskId,
              filename: filename,
              completedCount: entries.length,
              totalTokens: totalTokensUsed,
              current_translation_task: {
                taskId: currentTaskId,
                subtitle_entries: entries,
                subtitle_filename: filename,
                translation_progress: {
                  completed: entries.length,
                  total: entries.length,
                  tokens: totalTokensUsed,
                  status: 'completed'
                }
              }
            });
            
            console.log('å†å²è®°å½•å·²ä¿å­˜ (å¤‡ç”¨æ–¹æ¡ˆ) - tokens:', totalTokensUsed);
          }
        } catch (historyError) {
          console.error('ä¿å­˜å†å²è®°å½•å¤±è´¥:', historyError);
          // ä¸å½±å“ä¸»æµç¨‹ï¼Œåªæ˜¾ç¤ºè­¦å‘Š
          toast('ç¿»è¯‘å®Œæˆï¼Œä½†ä¿å­˜å†å²è®°å½•å¤±è´¥', { 
            icon: 'âš ï¸' 
          });
        }
        
        toast.success('ç¿»è¯‘å®Œæˆï¼');
      } catch (error) {
        // å¤„ç†ç¿»è¯‘è¿‡ç¨‹ä¸­çš„é”™è¯¯
        if (error.name === 'AbortError' || error.message?.includes('å–æ¶ˆ')) {
          toast.success('ç¿»è¯‘å·²æš‚åœ');
        } else {
          console.error('ç¿»è¯‘å¤±è´¥:', error);
          toast.error(`ç¿»è¯‘å¤±è´¥: ${error}`);
          await updateProgress(0, entries.length, 'direct', 'ç¿»è¯‘å¤±è´¥', undefined, totalTokensUsed);
          // åªåœ¨é”™è¯¯æƒ…å†µä¸‹æ‰åœæ­¢ç¿»è¯‘
          await stopTranslation();
        }
      }
      // æ³¨æ„ï¼šä¸åœ¨finallyä¸­è°ƒç”¨stopTranslationï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦ä¿æŒ'completed'çŠ¶æ€
    } catch (error) {
      console.error('åˆå§‹åŒ–ç¿»è¯‘å¤±è´¥:', error);
      toast.error(`åˆå§‹åŒ–ç¿»è¯‘å¤±è´¥: ${error}`);
    }
  }, [
        entries, 
    filename, 
    isConfigured, 
    config, 
    progress.current,
    progress.pausedAt,
    updateEntry, 
    translateBatch, 
    updateProgress, 
    initTranslation,
    stopTranslation,
    completeTranslation,
    getRelevantTerms,
    getCurrentTaskId,
    getTranslationProgress,
    onOpenSettings,
    addHistoryEntry, // æ·»åŠ å†å²è®°å½•å‡½æ•°ä¾èµ–
    tokensUsed, // æ·»åŠ tokensUsedä¾èµ–
    initializeBatchStates, // æ·»åŠ æ‰¹æ¬¡çŠ¶æ€ç®¡ç†å‡½æ•°
    saveBatchStates,
    loadBatchStates,
    updateBatchStatus
  ]);

  const handleToggleTranslation = useCallback(async () => {
    await toggleTranslation();
    
    // å¦‚æœä»æš‚åœçŠ¶æ€æ¢å¤ï¼Œæç¤ºç”¨æˆ·ç‚¹å‡»å¼€å§‹æŒ‰é’®
    if (isPaused && !isTranslating) {
      toast.success('å¯ä»¥ç»§ç»­ç¿»è¯‘äº†ï¼Œè¯·ç‚¹å‡»â€œå¼€å§‹ç¿»è¯‘â€ç»§ç»­');
    }
  }, [toggleTranslation, isPaused, isTranslating]);

  const handleExport = useCallback(async (format: 'srt' | 'txt' | 'bilingual') => {
    if (!entries.length) {
      toast.error('æ²¡æœ‰å¯å¯¼å‡ºçš„å­—å¹•');
      return;
    }

    setIsExporting(true);
    
    try {
      let content = '';
      let extension = '';
      
      switch (format) {
        case 'srt':
          content = exportSRT(true);
          extension = 'srt';
          break;
        case 'txt':
          content = exportTXT(true);
          extension = 'txt';
          break;
        case 'bilingual':
          content = exportBilingual();
          extension = 'srt';
          break;
      }
      
      const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      
      const baseName = filename.replace(/\.srt$/i, '');
      a.href = url;
      a.download = `${baseName}_translated.${extension}`;
      a.click();
      
      URL.revokeObjectURL(url);
      toast.success('å¯¼å‡ºæˆåŠŸ');
    } catch (error) {
      console.error('å¯¼å‡ºå¤±è´¥:', error);
      toast.error('å¯¼å‡ºå¤±è´¥');
    } finally {
      setIsExporting(false);
    }
  }, [entries, filename, exportSRT, exportTXT, exportBilingual]);

  if (!entries.length) {
    return null;
  }

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      className={`backdrop-blur-sm bg-white/10 rounded-xl p-6 ${className}`}
    >
      <div className="flex flex-wrap items-center justify-between gap-4">
        {/* ç¿»è¯‘æ§åˆ¶ */}
        <div className="flex items-center space-x-3">
          {/* ä¸»æ§åˆ¶æŒ‰é’®ï¼šå¼€å§‹/æš‚åœ/ç»§ç»­ */}
          {progress.phase === 'paused' && !isTranslating ? (
            // æš‚åœçŠ¶æ€ï¼šæ˜¾ç¤ºç»§ç»­æŒ‰é’®
            <button
              onClick={startTranslation}
              disabled={!isConfigured || isExporting}
              className="flex items-center space-x-2 px-6 py-3 rounded-lg font-medium transition-all duration-200 bg-green-500/20 hover:bg-green-500/30 text-green-200 border border-green-500/30 hover:scale-105"
            >
              <Play className="h-4 w-4" />
              <span>ç»§ç»­ç¿»è¯‘</span>
            </button>
          ) : isTranslating ? (
            // ç¿»è¯‘ä¸­ï¼šæ˜¾ç¤ºæš‚åœæŒ‰é’®
            <button
              onClick={handleToggleTranslation}
              className="flex items-center space-x-2 px-6 py-3 rounded-lg font-medium transition-all duration-200 bg-orange-500/20 hover:bg-orange-500/30 text-orange-200 border border-orange-500/30"
            >
              <Pause className="h-4 w-4" />
              <span>æš‚åœç¿»è¯‘</span>
            </button>
          ) : (
            // é»˜è®¤çŠ¶æ€ï¼šæ˜¾ç¤ºå¼€å§‹æŒ‰é’®
            <button
              onClick={startTranslation}
              disabled={(!isConfigured && !isTranslating) || isExporting}
              className={`
                flex items-center space-x-2 px-6 py-3 rounded-lg font-medium transition-all duration-200
                ${isConfigured
                  ? 'bg-purple-500/20 hover:bg-purple-500/30 text-purple-200 border border-purple-500/30 hover:scale-105'
                  : 'bg-gray-500/20 text-gray-400 border border-gray-500/30 cursor-not-allowed'
                }
              `}
            >
              <Play className="h-4 w-4" />
              <span>å¼€å§‹ç¿»è¯‘</span>
            </button>
          )}
          
          {!isConfigured && (
            <button
              onClick={onOpenSettings}
              className="flex items-center space-x-2 px-4 py-3 rounded-lg bg-orange-500/20 hover:bg-orange-500/30 text-orange-200 border border-orange-500/30 transition-all duration-200"
            >
              <Settings className="h-4 w-4" />
              <span>é…ç½®API</span>
            </button>
          )}
        </div>

        {/* å¯¼å‡ºæ§åˆ¶ */}
        <div className="flex items-center space-x-2">
          <div className="relative">
            <button
              onClick={() => setIsExporting(!isExporting)}
              disabled={entries.length === 0}
              className="flex items-center space-x-2 px-4 py-3 rounded-lg bg-blue-500/20 hover:bg-blue-500/30 text-blue-200 border border-blue-500/30 transition-all duration-200 hover:scale-105"
            >
              <Download className="h-4 w-4" />
              <span>å¯¼å‡º</span>
            </button>
            
            {isExporting && (
              <div className="absolute bottom-full mb-2 right-0 z-50">
                <div className="bg-black/90 backdrop-blur-sm rounded-lg p-1 space-y-1 min-w-[140px] shadow-2xl border border-white/20">
                  <button
                    onClick={() => {
                      handleExport('srt');
                      setIsExporting(false);
                    }}
                    className="w-full text-left px-4 py-3 text-sm text-white hover:bg-white/20 rounded-md transition-colors duration-150 flex items-center space-x-2"
                  >
                    <span>ğŸ“„</span>
                    <span>SRT æ ¼å¼</span>
                  </button>
                  <button
                    onClick={() => {
                      handleExport('txt');
                      setIsExporting(false);
                    }}
                    className="w-full text-left px-4 py-3 text-sm text-white hover:bg-white/20 rounded-md transition-colors duration-150 flex items-center space-x-2"
                  >
                    <span>ğŸ“</span>
                    <span>TXT æ ¼å¼</span>
                  </button>
                  <button
                    onClick={() => {
                      handleExport('bilingual');
                      setIsExporting(false);
                    }}
                    className="w-full text-left px-4 py-3 text-sm text-white hover:bg-white/20 rounded-md transition-colors duration-150 flex items-center space-x-2"
                  >
                    <span>ğŸ”„</span>
                    <span>åŒè¯­å¯¹ç…§</span>
                  </button>
                </div>
              </div>
            )}
            
            {/* ç‚¹å‡»å¤–éƒ¨åŒºåŸŸå…³é—­èœå•çš„é®ç½©å±‚ */}
            {isExporting && (
              <div
                className="fixed inset-0 z-40"
                onClick={() => setIsExporting(false)}
              />
            )}
          </div>
        </div>
      </div>
      
      {/* ç»Ÿè®¡ä¿¡æ¯ - ä»…åœ¨æ²¡æœ‰ç¿»è¯‘è¿›åº¦æ—¶æ˜¾ç¤º */}
      {!isTranslating && progress.total === 0 && (
        <div className="mt-4 flex flex-wrap items-center justify-between text-sm text-white/70">
          <div className="flex items-center space-x-4">
            <span>å­—å¹•æ¡æ•°: {entries.length}</span>
            <span>Tokenæ¶ˆè€—: {tokensUsed}</span>
          </div>
        </div>
      )}
    </motion.div>
  );
};