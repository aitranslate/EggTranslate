import React, { useState, useCallback } from 'react';
import { Play, Pause, Download, Settings } from 'lucide-react';
import { useSubtitle } from '@/contexts/SubtitleContext';
import { useTranslation } from '@/contexts/TranslationContext';
import { useTerms } from '@/contexts/TermsContext';
import { useHistory } from '@/contexts/HistoryContext';
import { TranslationHistoryEntry } from '@/types';
import { motion } from 'framer-motion';
import toast from 'react-hot-toast';
import localforage from 'localforage';

interface TranslationControlsProps {
  className?: string;
  onOpenSettings?: () => void;
}

export const TranslationControls: React.FC<TranslationControlsProps> = ({ 
  className,
  onOpenSettings 
}) => {
  const { 
    entries, 
    filename, 
    updateEntry, 
    exportSRT, 
    exportTXT, 
    exportBilingual,
    getTranslationProgress,
    getCurrentTaskId // 获取当前任务ID
  } = useSubtitle();
  const {
    config,
    isTranslating,
    isPaused,
    progress,
    tokensUsed,
    isConfigured,
    abortController,
    translateBatch,
    updateProgress,
    toggleTranslation,
    startTranslation: initTranslation,
    stopTranslation,
    completeTranslation
  } = useTranslation();
  const { getRelevantTerms } = useTerms();
  const { addHistoryEntry } = useHistory(); // 使用历史记录功能
  
  const [isExporting, setIsExporting] = useState(false);

  // 🎯 批次状态管理
  const initializeBatchStates = useCallback((batchSize: number) => {
    const totalBatches = Math.ceil(entries.length / batchSize);
    const batchStates = [];
    
    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      const startIdx = batchIndex * batchSize;
      const endIdx = Math.min(startIdx + batchSize, entries.length);
      const batchEntries = entries.slice(startIdx, endIdx);
      
      // 检查批次是否已完成（所有条目都有翻译文本）
      const isCompleted = batchEntries.every(entry => 
        entry.translatedText && entry.translatedText.trim() !== ''
      );
      
      batchStates.push({
        batchIndex,
        startIdx,
        endIdx,
        totalItems: batchEntries.length,
        status: isCompleted ? 'completed' : 'pending', // pending, processing, completed, failed
        entries: batchEntries
      });
    }
    
    return batchStates;
  }, [entries]);
  
  // 🎯 持久化批次状态
  const saveBatchStates = useCallback(async (batchStates: any[]) => {
    try {
      const taskId = getCurrentTaskId();
      const batchStatesKey = `batch_states_${taskId}`;
      
      const batchData = {
        taskId,
        filename,
        totalBatches: batchStates.length,
        batchStates,
        lastUpdated: Date.now()
      };
      
      localStorage.setItem(batchStatesKey, JSON.stringify(batchData));
      console.log('批次状态已保存:', batchData);
    } catch (error) {
      console.error('保存批次状态失败:', error);
    }
  }, [getCurrentTaskId, filename]);
  
  // 🎯 加载批次状态
  const loadBatchStates = useCallback(async (batchSize: number) => {
    try {
      const taskId = getCurrentTaskId();
      const batchStatesKey = `batch_states_${taskId}`;
      const savedData = localStorage.getItem(batchStatesKey);
      
      if (savedData) {
        const batchData = JSON.parse(savedData);
        console.log('加载已保存的批次状态:', batchData);
        return batchData.batchStates;
      }
    } catch (error) {
      console.error('加载批次状态失败:', error);
    }
    
    // 如果没有保存的状态，初始化新的状态
    return initializeBatchStates(batchSize);
  }, [getCurrentTaskId, initializeBatchStates]);
  
  // 🎯 更新批次状态
  const updateBatchStatus = useCallback(async (batchIndex: number, status: string, batchStates: any[]) => {
    const updatedStates = [...batchStates];
    if (updatedStates[batchIndex]) {
      updatedStates[batchIndex].status = status;
      await saveBatchStates(updatedStates);
    }
    return updatedStates;
  }, [saveBatchStates]);

  const startTranslation = useCallback(async () => {
    if (!entries.length) {
      toast.error('请先上传SRT文件');
      return;
    }

    if (!isConfigured) {
      toast.error('请先配置API设置');
      onOpenSettings?.();
      return;
    }

    try {
      // 初始化翻译状态并获取AbortController
      const controller = await initTranslation();
      
      // 获取当前任务ID
      const currentTaskId = getCurrentTaskId();
      
      // 初始化tokens累计器，从当前值开始
      let totalTokensUsed = tokensUsed;
      console.log('翻译任务已启动:', { taskId: currentTaskId, filename, entriesCount: entries.length, initialTokens: totalTokensUsed });

      const { batchSize, contextBefore, contextAfter, threadCount } = config;
      
      // 🎯 加载或初始化批次状态
      let batchStates = await loadBatchStates(batchSize);
      
      // 🎯 更可靠的进度获取函数
      const getReliableProgress = async () => {
        let completedCount = 0;
        try {
          // 从 localStorage 中读取最新的字幕数据
          const currentTaskJson = localStorage.getItem('current_translation_task');
          if (currentTaskJson) {
            const currentTask = JSON.parse(currentTaskJson);
            if (currentTask.subtitle_entries) {
              completedCount = currentTask.subtitle_entries.filter(entry => 
                entry.translatedText && entry.translatedText.trim() !== ''
              ).length;
            }
          }
          
          // 如果 localStorage 中没有数据，使用React状态
          if (completedCount === 0) {
            completedCount = entries.filter(entry => 
              entry.translatedText && entry.translatedText.trim() !== ''
            ).length;
          }
        } catch (error) {
          console.error('读取localStorage进度失败，使用React状态:', error);
          completedCount = entries.filter(entry => 
            entry.translatedText && entry.translatedText.trim() !== ''
          ).length;
        }
        
        return {
          completed: completedCount,
          total: entries.length,
          percentage: Math.round((completedCount / entries.length) * 100)
        };
      };
      
      const actualProgress = await getReliableProgress();
      await updateProgress(actualProgress.completed, entries.length, 'direct', `准备翻译... (已完成: ${actualProgress.completed}/${entries.length})`, undefined, totalTokensUsed);

      // 🎯 基于批次状态的翻译逻辑
      try {
        // 获取所有未完成的批次
        const pendingBatches = batchStates.filter(batch => batch.status === 'pending');
        
        if (pendingBatches.length === 0) {
          toast.success('所有批次都已完成翻译！');
          await completeTranslation(totalTokensUsed);
          return;
        }
        
        console.log(`开始批次状态管理的翻译: 待处理批次 ${pendingBatches.length}, 线程数 ${threadCount}`);
        
        // 为未完成的批次准备翻译数据
        const allBatches = [];
        for (const batchState of pendingBatches) {
          const { batchIndex, startIdx, endIdx } = batchState;
          const batchEntries = entries.slice(startIdx, endIdx);
          
          // 跳过已翻译的条目
          const untranslatedEntries = batchEntries.filter(entry => 
            !entry.translatedText || !entry.translatedText.trim()
          );
          
          // 如果整个批次都已翻译，更新状态并跳过
          if (untranslatedEntries.length === 0) {
            console.log(`批次 ${batchIndex + 1} 已完成，更新状态`);
            batchStates = await updateBatchStatus(batchIndex, 'completed', batchStates);
            continue;
          }
          
          // 获取上下文
          const contextBeforeTexts = entries
            .slice(Math.max(0, startIdx - contextBefore), startIdx)
            .map(e => e.text)
            .join('\n');
          
          const contextAfterTexts = entries
            .slice(endIdx, Math.min(entries.length, endIdx + contextAfter))
            .map(e => e.text)
            .join('\n');
          
          // 获取相关术语
          const batchText = untranslatedEntries.map(e => e.text).join(' ');
          const relevantTerms = getRelevantTerms(batchText);
          const termsText = relevantTerms
            .map(term => `${term.original} -> ${term.translation}`)
            .join('\n');

          const textsToTranslate = untranslatedEntries.map(e => e.text);
          
          allBatches.push({
            batchIndex,
            startIdx,
            endIdx,
            batchEntries,
            untranslatedEntries,
            textsToTranslate,
            contextBeforeTexts,
            contextAfterTexts,
            termsText
          });
        }
        
        console.log(`实际需要翻译的批次: ${allBatches.length}`);
        
        // 🎯 基于实际状态的进度更新
        const updateRealTimeProgress = async () => {
          let actualCompletedCount = 0;
          try {
            // 从 localStorage 中读取最新的字幕数据
            const currentTaskJson = localStorage.getItem('current_translation_task');
            if (currentTaskJson) {
              const currentTask = JSON.parse(currentTaskJson);
              if (currentTask.subtitle_entries) {
                actualCompletedCount = currentTask.subtitle_entries.filter(entry => 
                  entry.translatedText && entry.translatedText.trim() !== ''
                ).length;
              }
            }
            
            if (actualCompletedCount === 0) {
              await new Promise(resolve => setTimeout(resolve, 200));
              actualCompletedCount = entries.filter(entry => 
                entry.translatedText && entry.translatedText.trim() !== ''
              ).length;
            }
          } catch (error) {
            console.error('读取localStorage进度失败，使用备用方案:', error);
            await new Promise(resolve => setTimeout(resolve, 200));
            actualCompletedCount = entries.filter(entry => 
              entry.translatedText && entry.translatedText.trim() !== ''
            ).length;
          }
          
          const statusText = `翻译中... (${actualCompletedCount}/${entries.length}) [${threadCount}线程] ${Math.round((actualCompletedCount / entries.length) * 100)}%`;
          
          await updateProgress(
            actualCompletedCount,
            entries.length,
            'direct',
            statusText,
            undefined,
            totalTokensUsed
          );
          
          console.log(`实时进度更新: ${actualCompletedCount}/${entries.length} (${Math.round((actualCompletedCount / entries.length) * 100)}%)`);
        };
        
        // 🎯 统一暂停逻辑：基于实际状态
        const performAtomicPause = async (reason: string) => {
          const actualProgress = await getReliableProgress();
          
          await updateProgress(
            actualProgress.completed,
            entries.length,
            'paused',
            `已暂停 (进度: ${actualProgress.percentage}%) - ${reason}`,
            undefined, // 不再使用批次索引，因为我们现在有批次状态
            totalTokensUsed
          );
          
          console.log(`暂停状态更新 - 真实已完成: ${actualProgress.completed}`);
          toast.success('翻译已暂停');
        };
        
        // 🎯 终止所有正在进行的翻译线程
        const abortAllBatches = () => {
          console.log('终止所有正在进行的翻译线程...');
          if (controller && !controller.signal.aborted) {
            controller.abort();
          }
        };
        

        // 🎯 使用Promise.all进行并发处理，按threadCount分组
        for (let i = 0; i < allBatches.length; i += threadCount) {
          // 检查是否被取消
          if (controller.signal.aborted) {
            await performAtomicPause('用户手动暂停');
            return;
          }
          
          // 获取当前线程组的批次
          const currentBatchGroup = allBatches.slice(i, i + threadCount);
          
          // 标记当前批次为“处理中”
          for (const batch of currentBatchGroup) {
            batchStates = await updateBatchStatus(batch.batchIndex, 'processing', batchStates);
          }
          
          // 并发处理当前线程组的批次
          const batchPromises = currentBatchGroup.map(async (batch) => {
            try {
              // 翻译前，再次检查中止信号
              if (controller.signal.aborted) {
                console.log(`批次 ${batch.batchIndex + 1} 在开始前被中止`);
                await updateBatchStatus(batch.batchIndex, 'pending', batchStates);
                throw new Error('翻译被暂停');
              }
              
              // 记录翻译前的Token数
              const beforeTokens = totalTokensUsed;
              
              // 传入AbortSignal进行翻译
              const translationResult = await translateBatch(
                batch.textsToTranslate,
                controller.signal,
                batch.contextBeforeTexts,
                batch.contextAfterTexts,
                batch.termsText
              );
              
              // 🚀 在收到翻译结果后立即保存，确保不丢失数据
              if (translationResult && translationResult.translations) {
                // 更新条目
                translationResult.translations.forEach((translation: string, index: number) => {
                  if (batch.untranslatedEntries[index]) {
                    const entryIndex = entries.findIndex(e => e.id === batch.untranslatedEntries[index].id);
                    if (entryIndex !== -1 && translation && translation.trim()) {
                      updateEntry(entryIndex, translation.trim());
                    }
                  }
                });
                
                // 等待状态同步
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // 更新Token数
                if (translationResult.tokensUsed) {
                  totalTokensUsed += translationResult.tokensUsed;
                }
                
                // 更新进度
                await updateRealTimeProgress();
                
                // 标记批次为已完成
                batchStates = await updateBatchStatus(batch.batchIndex, 'completed', batchStates);
                
                console.log(`批次 ${batch.batchIndex + 1} 翻译完成，状态已保存`);
                
                // 在收到翻译结果并保存后，再检查中止信号
                if (controller.signal.aborted) {
                  console.log(`批次 ${batch.batchIndex + 1} 翻译完成但收到取消信号，结果已保存`);
                  return { batchIndex: batch.batchIndex, success: true, completed: true };
                }
                
                return { batchIndex: batch.batchIndex, success: true };
              } else {
                throw new Error('翻译结果为空');
              }
            } catch (error) {
              if (error.name === 'AbortError' || error.message?.includes('取消') || error.message?.includes('暂停')) {
                console.log(`批次 ${batch.batchIndex + 1} 被取消`);
                await updateBatchStatus(batch.batchIndex, 'pending', batchStates); // 重置为待处理状态
                return { batchIndex: batch.batchIndex, success: false, cancelled: true };
              } else {
                console.error(`批次 ${batch.batchIndex + 1} 翻译失败:`, error);
                await updateBatchStatus(batch.batchIndex, 'failed', batchStates);
                toast.error(`批次 ${batch.batchIndex + 1} 翻译失败: ${error}`);
                return { batchIndex: batch.batchIndex, success: false, error };
              }
            }
          });
          
          // 等待当前线程组完成
          const results = await Promise.all(batchPromises);
          
          // 检查结果
          const successfulBatches = results.filter(r => r.success);
          const failedBatches = results.filter(r => !r.success && !r.cancelled);
          const cancelledBatches = results.filter(r => r.cancelled);
          
          console.log(`线程组完成: 成功 ${successfulBatches.length}, 失败 ${failedBatches.length}, 取消 ${cancelledBatches.length}`);
          
          // 如果有失败的批次，显示警告但继续
          if (failedBatches.length > 0) {
            toast(`${failedBatches.length} 个批次翻译失败，将在下次继续时重试`, { 
              icon: '⚠️' 
            });
          }
          
          // 如果有取消的批次，说明用户手动暂停了
          if (cancelledBatches.length > 0) {
            await performAtomicPause('翻译过程中暂停，部分结果已保存');
            return;
          }
          
          // 检查是否所有批次都已完成
          const remainingPendingBatches = batchStates.filter(b => b.status === 'pending' || b.status === 'failed');
          if (remainingPendingBatches.length === 0) {
            console.log('所有批次已完成！');
            break;
          }
        }在updateRealTimeProgress中更新了进度
          } catch (error) {
            // 如果是取消错误，处理暂停逻辑
            if (error.name === 'AbortError' || error.message?.includes('取消')) {
              // 🚫 修复：使用原子化暂停更新，避免状态不一致
              await performAtomicPause('翻译过程中暂停');
              return;
            }
            
            // 其他错误继续处理下一组
            console.error('线程组处理失败:', error);
          }
        }

        // 正常完成 - 使用实际状态确保准确性
        const finalProgress = await getReliableProgress();
        await updateProgress(finalProgress.completed, entries.length, 'completed', '翻译完成', undefined, totalTokensUsed);
        
        // 使用新的completeTranslation函数保持completed状态
        await completeTranslation(totalTokensUsed);
        
        // 保存历史记录（此时状态是'completed'，Token数据完整）
        try {
          // 等待一小段时间，确保 completeTranslation 已完成
          await new Promise(resolve => setTimeout(resolve, 100));
          
          // 获取当前任务的完整数据
          const currentTaskData = await localforage.getItem('current_translation_task') as any;
          
          if (currentTaskData) {
            // 确保数据完整性
            const finalTokenCount = totalTokensUsed;
            currentTaskData.translation_progress.tokens = finalTokenCount;
            currentTaskData.translation_progress.status = 'completed';
            
            await addHistoryEntry({
              taskId: currentTaskId,
              filename: filename,
              completedCount: entries.length,
              totalTokens: finalTokenCount,
              current_translation_task: currentTaskData
            });
            
            console.log('历史记录已保存 - 最终tokens:', finalTokenCount, '状态:', currentTaskData.translation_progress.status);
          } else {
            // 备用方案：构造完整的任务数据
            await addHistoryEntry({
              taskId: currentTaskId,
              filename: filename,
              completedCount: entries.length,
              totalTokens: totalTokensUsed,
              current_translation_task: {
                taskId: currentTaskId,
                subtitle_entries: entries,
                subtitle_filename: filename,
                translation_progress: {
                  completed: entries.length,
                  total: entries.length,
                  tokens: totalTokensUsed,
                  status: 'completed'
                }
              }
            });
            
            console.log('历史记录已保存 (备用方案) - tokens:', totalTokensUsed);
          }
        } catch (historyError) {
          console.error('保存历史记录失败:', historyError);
          // 不影响主流程，只显示警告
          toast('翻译完成，但保存历史记录失败', { 
            icon: '⚠️' 
          });
        }
        
        toast.success('翻译完成！');
      } catch (error) {
        // 处理翻译过程中的错误
        if (error.name === 'AbortError' || error.message?.includes('取消')) {
          toast.success('翻译已暂停');
        } else {
          console.error('翻译失败:', error);
          toast.error(`翻译失败: ${error}`);
          await updateProgress(0, entries.length, 'direct', '翻译失败', undefined, totalTokensUsed);
          // 只在错误情况下才停止翻译
          await stopTranslation();
        }
      }
      // 注意：不在finally中调用stopTranslation，因为我们需要保持'completed'状态
    } catch (error) {
      console.error('初始化翻译失败:', error);
      toast.error(`初始化翻译失败: ${error}`);
    }
  }, [
        entries, 
    filename, 
    isConfigured, 
    config, 
    progress.current,
    progress.pausedAt,
    updateEntry, 
    translateBatch, 
    updateProgress, 
    initTranslation,
    stopTranslation,
    completeTranslation,
    getRelevantTerms,
    getCurrentTaskId,
    getTranslationProgress,
    onOpenSettings,
    addHistoryEntry, // 添加历史记录函数依赖
    tokensUsed, // 添加tokensUsed依赖
    initializeBatchStates, // 添加批次状态管理函数
    saveBatchStates,
    loadBatchStates,
    updateBatchStatus
  ]);

  const handleToggleTranslation = useCallback(async () => {
    await toggleTranslation();
    
    // 如果从暂停状态恢复，提示用户点击开始按钮
    if (isPaused && !isTranslating) {
      toast.success('可以继续翻译了，请点击“开始翻译”继续');
    }
  }, [toggleTranslation, isPaused, isTranslating]);

  const handleExport = useCallback(async (format: 'srt' | 'txt' | 'bilingual') => {
    if (!entries.length) {
      toast.error('没有可导出的字幕');
      return;
    }

    setIsExporting(true);
    
    try {
      let content = '';
      let extension = '';
      
      switch (format) {
        case 'srt':
          content = exportSRT(true);
          extension = 'srt';
          break;
        case 'txt':
          content = exportTXT(true);
          extension = 'txt';
          break;
        case 'bilingual':
          content = exportBilingual();
          extension = 'srt';
          break;
      }
      
      const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      
      const baseName = filename.replace(/\.srt$/i, '');
      a.href = url;
      a.download = `${baseName}_translated.${extension}`;
      a.click();
      
      URL.revokeObjectURL(url);
      toast.success('导出成功');
    } catch (error) {
      console.error('导出失败:', error);
      toast.error('导出失败');
    } finally {
      setIsExporting(false);
    }
  }, [entries, filename, exportSRT, exportTXT, exportBilingual]);

  if (!entries.length) {
    return null;
  }

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      className={`backdrop-blur-sm bg-white/10 rounded-xl p-6 ${className}`}
    >
      <div className="flex flex-wrap items-center justify-between gap-4">
        {/* 翻译控制 */}
        <div className="flex items-center space-x-3">
          {/* 主控制按钮：开始/暂停/继续 */}
          {progress.phase === 'paused' && !isTranslating ? (
            // 暂停状态：显示继续按钮
            <button
              onClick={startTranslation}
              disabled={!isConfigured || isExporting}
              className="flex items-center space-x-2 px-6 py-3 rounded-lg font-medium transition-all duration-200 bg-green-500/20 hover:bg-green-500/30 text-green-200 border border-green-500/30 hover:scale-105"
            >
              <Play className="h-4 w-4" />
              <span>继续翻译</span>
            </button>
          ) : isTranslating ? (
            // 翻译中：显示暂停按钮
            <button
              onClick={handleToggleTranslation}
              className="flex items-center space-x-2 px-6 py-3 rounded-lg font-medium transition-all duration-200 bg-orange-500/20 hover:bg-orange-500/30 text-orange-200 border border-orange-500/30"
            >
              <Pause className="h-4 w-4" />
              <span>暂停翻译</span>
            </button>
          ) : (
            // 默认状态：显示开始按钮
            <button
              onClick={startTranslation}
              disabled={(!isConfigured && !isTranslating) || isExporting}
              className={`
                flex items-center space-x-2 px-6 py-3 rounded-lg font-medium transition-all duration-200
                ${isConfigured
                  ? 'bg-purple-500/20 hover:bg-purple-500/30 text-purple-200 border border-purple-500/30 hover:scale-105'
                  : 'bg-gray-500/20 text-gray-400 border border-gray-500/30 cursor-not-allowed'
                }
              `}
            >
              <Play className="h-4 w-4" />
              <span>开始翻译</span>
            </button>
          )}
          
          {!isConfigured && (
            <button
              onClick={onOpenSettings}
              className="flex items-center space-x-2 px-4 py-3 rounded-lg bg-orange-500/20 hover:bg-orange-500/30 text-orange-200 border border-orange-500/30 transition-all duration-200"
            >
              <Settings className="h-4 w-4" />
              <span>配置API</span>
            </button>
          )}
        </div>

        {/* 导出控制 */}
        <div className="flex items-center space-x-2">
          <div className="relative">
            <button
              onClick={() => setIsExporting(!isExporting)}
              disabled={entries.length === 0}
              className="flex items-center space-x-2 px-4 py-3 rounded-lg bg-blue-500/20 hover:bg-blue-500/30 text-blue-200 border border-blue-500/30 transition-all duration-200 hover:scale-105"
            >
              <Download className="h-4 w-4" />
              <span>导出</span>
            </button>
            
            {isExporting && (
              <div className="absolute bottom-full mb-2 right-0 z-50">
                <div className="bg-black/90 backdrop-blur-sm rounded-lg p-1 space-y-1 min-w-[140px] shadow-2xl border border-white/20">
                  <button
                    onClick={() => {
                      handleExport('srt');
                      setIsExporting(false);
                    }}
                    className="w-full text-left px-4 py-3 text-sm text-white hover:bg-white/20 rounded-md transition-colors duration-150 flex items-center space-x-2"
                  >
                    <span>📄</span>
                    <span>SRT 格式</span>
                  </button>
                  <button
                    onClick={() => {
                      handleExport('txt');
                      setIsExporting(false);
                    }}
                    className="w-full text-left px-4 py-3 text-sm text-white hover:bg-white/20 rounded-md transition-colors duration-150 flex items-center space-x-2"
                  >
                    <span>📝</span>
                    <span>TXT 格式</span>
                  </button>
                  <button
                    onClick={() => {
                      handleExport('bilingual');
                      setIsExporting(false);
                    }}
                    className="w-full text-left px-4 py-3 text-sm text-white hover:bg-white/20 rounded-md transition-colors duration-150 flex items-center space-x-2"
                  >
                    <span>🔄</span>
                    <span>双语对照</span>
                  </button>
                </div>
              </div>
            )}
            
            {/* 点击外部区域关闭菜单的遮罩层 */}
            {isExporting && (
              <div
                className="fixed inset-0 z-40"
                onClick={() => setIsExporting(false)}
              />
            )}
          </div>
        </div>
      </div>
      
      {/* 统计信息 - 仅在没有翻译进度时显示 */}
      {!isTranslating && progress.total === 0 && (
        <div className="mt-4 flex flex-wrap items-center justify-between text-sm text-white/70">
          <div className="flex items-center space-x-4">
            <span>字幕条数: {entries.length}</span>
            <span>Token消耗: {tokensUsed}</span>
          </div>
        </div>
      )}
    </motion.div>
  );
};